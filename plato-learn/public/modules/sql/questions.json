{
  "schema": {
    "students": "id (INT), name (TEXT), email (TEXT), major (TEXT), year_started (INT), gpa (DECIMAL)",
    "courses": "course_id (INT), title (TEXT), credits (INT), dept_id (TEXT)",
    "enrollments": "student_id (INT), course_id (INT), semester (TEXT), grade (DECIMAL)",
    "departments": "dept_id (TEXT), name (TEXT), building (TEXT)"
  },
  "rounds": [
    {
      "id": "r1",
      "name": "The SELECT Statement",
      "description": "Master the anatomy of a query: SELECT, FROM, and DISTINCT.",
      "prerequisites": [],
      "row": 0,
      "col": 0,
      "lesson": [
        {
          "title": "Anatomy of a Query",
          "content": "Every SQL query starts with `SELECT`. This tells the database **which columns** you want to retrieve.\n\nThen, functionality matches `FROM` to tell it **which table** has those columns.\n\n### Syntax\n```sql\nSELECT column1, column2\nFROM table_name;\n```\n\n### The University Database\nWe will be querying a university database with tables like `students`, `courses`, and `enrollments`."
        },
        {
          "title": "Selecting All Columns",
          "content": "If you want **every** column, use the asterisk (`*`) wildcard.\n\n```sql\nSELECT * FROM students;\n```\n\nThis returns the student's ID, name, email, major, etc."
        },
        {
          "title": "Eliminating Duplicates",
          "content": "Use `DISTINCT` to return only unique values.\n\n```sql\nSELECT DISTINCT major FROM students;\n```\n\nIf 50 students are 'Computer Science', this returns 'Computer Science' only once."
        }
      ],
      "questions": [
        {
          "id": "q1_1",
          "type": "multiple-choice",
          "goal": "Retrieve all columns from the students table",
          "q": "Which query selects ALL data for every student?",
          "choices": [
            "SELECT * FROM students",
            "SELECT all FROM students",
            "SELECT students FROM *",
            "GET * FROM students"
          ],
          "a": "SELECT * FROM students",
          "ctx": [
            "students"
          ],
          "hint": "The asterisk (*) symbol represents 'all columns'.",
          "distractors": [
            "SELECT all FROM students",
            "SELECT students FROM *"
          ]
        },
        {
          "id": "q1_2",
          "type": "freeform-sql",
          "goal": "Select specific columns",
          "q": "Write a query to select ONLY the `name` and `email` of every student.",
          "a": [
            "SELECT name, email FROM students"
          ],
          "ctx": [
            "students"
          ],
          "hint": "Separate column names with a comma."
        },
        {
          "id": "q1_3",
          "type": "code-ordering",
          "goal": "Construct a valid query",
          "q": "Arrange the blocks to select unique majors.",
          "a": [
            "SELECT",
            "DISTINCT",
            "major",
            "FROM",
            "students"
          ],
          "ctx": [
            "students"
          ],
          "hint": "SELECT comes first, then modifiers like DISTINCT.",
          "distractors": [
            "UNIQUE",
            "list"
          ]
        },
        {
          "id": "q1_4",
          "type": "freeform-sql",
          "goal": "Fix the syntax error",
          "q": "Fix this query: `SELECT name major FROM students`",
          "a": [
            "SELECT name, major FROM students"
          ],
          "ctx": [
            "students"
          ],
          "hint": "Columns must be separated by commas.",
          "explanation": "You missed the comma between `name` and `major`."
        },
        {
          "id": "q1_5",
          "type": "type-in",
          "goal": "Complete the query",
          "q": "SELECT name ____ students;",
          "a": "FROM",
          "ctx": [
            "students"
          ],
          "hint": "Which keyword specifies the table?"
        }
      ]
    },
    {
      "id": "r2",
      "name": "Filtering Data (WHERE)",
      "description": "Standard logical operators, AND/OR, and fuzzy matching.",
      "prerequisites": [
        "r1"
      ],
      "row": 1,
      "col": 0,
      "lesson": [
        {
          "title": "The WHERE Clause",
          "content": "Use `WHERE` to filter rows that meet specific conditions.\n\n```sql\nSELECT name FROM students\nWHERE gpa > 3.5;\n```"
        },
        {
          "title": "Logical Operators",
          "content": "You can combine conditions using `AND`, `OR`, and `NOT`.\n\n```sql\nSELECT * FROM students\nWHERE major = 'CS'\n  AND year_started = 2023;\n```"
        },
        {
          "title": "Pattern Matching",
          "content": "Use `LIKE` for fuzzy matching with wildcards:\n- `%`: Matches any sequence of characters\n- `_`: Matches a single character\n\n```sql\n-- Finds majors containing 'Data'\nSELECT * FROM courses\nWHERE title LIKE '%Data%';\n```"
        }
      ],
      "questions": [
        {
          "id": "q2_1",
          "type": "freeform-sql",
          "goal": "Filter by number",
          "q": "Select the `name` of all students with a `gpa` greater than 3.0.",
          "a": [
            "SELECT name FROM students WHERE gpa > 3.0",
            "SELECT name FROM students WHERE gpa > 3"
          ],
          "ctx": [
            "students"
          ],
          "hint": "Use the > operator."
        },
        {
          "id": "q2_2",
          "type": "freeform-sql",
          "goal": "Filter by text",
          "q": "Select all columns for students whose `major` is 'History'.",
          "a": [
            "SELECT * FROM students WHERE major = 'History'"
          ],
          "ctx": [
            "students"
          ],
          "hint": "Text strings must be in single quotes."
        },
        {
          "id": "q2_3",
          "type": "freeform-sql",
          "goal": "Combine conditions",
          "q": "Find students named 'John' who also have a `gpa` of 4.0.",
          "a": [
            "SELECT * FROM students WHERE name = 'John' AND gpa = 4.0"
          ],
          "ctx": [
            "students"
          ],
          "hint": "Use AND to require both conditions."
        },
        {
          "id": "q2_4",
          "type": "multiple-choice",
          "goal": "Understanding OR vs AND",
          "q": "We want students who are EITHER 'CS' majors OR started in 2024. Which query is correct?",
          "choices": [
            "WHERE major = 'CS' OR year_started = 2024",
            "WHERE major = 'CS' AND year_started = 2024",
            "WHERE major = 'CS' XOR year_started = 2024"
          ],
          "a": "WHERE major = 'CS' OR year_started = 2024",
          "ctx": [
            "students"
          ],
          "hint": "We want the union of both sets, so if either condition is true, keep the row.",
          "distractors": []
        },
        {
          "id": "q2_5",
          "type": "code-ordering",
          "goal": "Range filtering",
          "q": "Construct a query to find GPAs between 2.5 and 3.5.",
          "a": [
            "SELECT",
            "*",
            "FROM",
            "students",
            "WHERE",
            "gpa",
            "BETWEEN",
            "2.5",
            "AND",
            "3.5"
          ],
          "ctx": [
            "students"
          ],
          "hint": "BETWEEN x AND y is cleaner than >= and <=",
          "distractors": []
        },
        {
          "id": "q2_6",
          "type": "freeform-sql",
          "goal": "Fuzzy Search",
          "q": "Find all courses where the title contains the word 'Intro'. select *",
          "a": [
            "SELECT * FROM courses WHERE title LIKE '%Intro%'"
          ],
          "ctx": [
            "courses"
          ],
          "hint": "Use LIKE with percent signs around the word."
        }
      ]
    },
    {
      "id": "r3",
      "name": "Aggregation & Groups",
      "description": "Summarize data with COUNT, SUM, AVG and GROUP BY.",
      "prerequisites": [
        "r1"
      ],
      "row": 1,
      "col": 1,
      "lesson": [
        {
          "title": "Aggregate Functions",
          "content": "Aggregates take many rows and return a single number.\n\n- `COUNT(*)`: Rows count\n- `SUM(col)`: Total value\n- `AVG(col)`: Average value\n- `MIN(col)` / `MAX(col)`"
        },
        {
          "title": "GROUP BY",
          "content": "Instead of one total for the whole table, `GROUP BY` calculates aggregates *per category*.\n\n```sql\nSELECT major, AVG(gpa)\nFROM students\nGROUP BY major;\n```\nThis gives one average GPA per major."
        },
        {
          "title": "HAVING vs WHERE",
          "content": "- `WHERE` filters rows **before** grouping.\n- `HAVING` filters groups **after** aggregation.\n\n```sql\n-- Only majors with > 100 students\nSELECT major, COUNT(*)\nFROM students\nGROUP BY major\nHAVING COUNT(*) > 100;\n```"
        }
      ],
      "questions": [
        {
          "id": "q3_1",
          "type": "type-in",
          "goal": "Count rows",
          "q": "SELECT ____(*) FROM students;",
          "a": "COUNT",
          "ctx": [
            "students"
          ],
          "hint": "The function to count rows."
        },
        {
          "id": "q3_2",
          "type": "freeform-sql",
          "goal": "Calculate Average",
          "q": "Calculate the average `gpa` of all students.",
          "a": [
            "SELECT AVG(gpa) FROM students"
          ],
          "ctx": [
            "students"
          ],
          "hint": "Use the AVG function."
        },
        {
          "id": "q3_3",
          "type": "freeform-sql",
          "goal": "Group By Basic",
          "q": "Count how many students are in each `year_started`. Return the year and the count.",
          "a": [
            "SELECT year_started, COUNT(*) FROM students GROUP BY year_started"
          ],
          "ctx": [
            "students"
          ],
          "hint": "Don't forget the GROUP BY clause at the end."
        },
        {
          "id": "q3_4",
          "type": "spot-error",
          "goal": "Identify Grouping Error",
          "q": "Why does this fail? SELECT major, AVG(gpa) FROM students WHERE AVG(gpa) > 3.0 GROUP BY major",
          "a": "You cannot use aggregates in WHERE. Use HAVING instead.",
          "ctx": [
            "students"
          ],
          "hint": "WHERE happens before averaging. How do you filter AFTER averaging?",
          "distractors": [],
          "choices": [
            "You cannot use aggregates in WHERE. Use HAVING instead.",
            "GROUP BY must come before WHERE.",
            "AVG is not a valid SQL function."
          ]
        },
        {
          "id": "q3_5",
          "type": "code-ordering",
          "goal": "Construct HAVING query",
          "q": "Find depts with more than 5 courses.",
          "a": [
            "SELECT",
            "dept_id",
            "FROM",
            "courses",
            "GROUP BY",
            "dept_id",
            "HAVING",
            "COUNT(*)",
            ">",
            "5"
          ],
          "ctx": [
            "courses"
          ],
          "hint": "GROUP BY comes before HAVING.",
          "distractors": [
            "WHERE"
          ]
        }
      ]
    },
    {
      "id": "r4",
      "name": "Joins (Inner & Left)",
      "description": "Combine data from multiple tables using keys.",
      "prerequisites": [
        "r2",
        "r3"
      ],
      "row": 2,
      "col": 0,
      "lesson": [
        {
          "title": "Why Join?",
          "content": "Data is split into authorized tables. `students` has names, `enrollments` has grades. To see \"Student Name and Grade\", you link them.\n\nThey link via keys: `students.id` matches `enrollments.student_id`."
        },
        {
          "title": "INNER JOIN",
          "content": "Keep rows only if they exist in BOTH tables.\n\n```sql\nSELECT s.name, e.grade\nFROM students s\nJOIN enrollments e ON s.id = e.student_id;\n```"
        },
        {
          "title": "LEFT JOIN",
          "content": "Keep ALL rows from the left (first) table, unmatched right rows become NULL.\n\nGood for finding students with *no* enrollments."
        }
      ],
      "questions": [
        {
          "id": "q4_1",
          "type": "multiple-choice",
          "goal": "Identify Join Keys",
          "q": "To join `students` and `enrollments`, which columns should be equal?",
          "choices": [
            "students.id = enrollments.student_id",
            "students.name = enrollments.grade",
            "students.email = enrollments.semester",
            "students.id = enrollments.id"
          ],
          "a": "students.id = enrollments.student_id",
          "ctx": [
            "students",
            "enrollments"
          ],
          "hint": "Look for the Foreign Key in enrollment that points to student.",
          "distractors": []
        },
        {
          "id": "q4_2",
          "type": "freeform-sql",
          "goal": "Write basic Join",
          "q": "Join `courses` and `departments`. Select the course `title` and department `name`.",
          "a": [
            "SELECT courses.title, departments.name FROM courses JOIN departments ON courses.dept_id = departments.dept_id",
            "SELECT c.title, d.name FROM courses c JOIN departments d ON c.dept_id = d.dept_id"
          ],
          "ctx": [
            "courses",
            "departments"
          ],
          "hint": "Use JOIN ... ON ..."
        },
        {
          "id": "q4_3",
          "type": "fill-blank",
          "goal": "Left Join Syntax",
          "q": "SELECT s.name FROM students s ____ JOIN enrollments e ON s.id = e.student_id;",
          "a": "LEFT",
          "ctx": [
            "students",
            "enrollments"
          ],
          "hint": "We want all students even if they have no classes."
        },
        {
          "id": "q4_4",
          "type": "code-ordering",
          "goal": "Join Ordering",
          "q": "Construct a join query.",
          "a": [
            "SELECT",
            "*",
            "FROM",
            "students",
            "JOIN",
            "enrollments",
            "ON",
            "students.id",
            "=",
            "enrollments.student_id"
          ],
          "ctx": [
            "students",
            "enrollments"
          ],
          "hint": "FROM Table1 JOIN Table2 ON Condition",
          "distractors": [
            "WHERE"
          ]
        },
        {
          "id": "q4_5",
          "type": "freeform-sql",
          "goal": "3-Table Join",
          "q": "Harder: Join students to enrollments, then to courses. Select student `name` and course `title`.",
          "a": [
            "SELECT students.name, courses.title FROM students JOIN enrollments ON students.id = enrollments.student_id JOIN courses ON enrollments.course_id = courses.course_id"
          ],
          "ctx": [
            "students",
            "enrollments",
            "courses"
          ],
          "hint": "Just chain a second JOIN statement."
        }
      ]
    },
    {
      "id": "r5",
      "name": "Subqueries",
      "description": "Nested queries for dynamic filtering.",
      "prerequisites": [
        "r4"
      ],
      "row": 3,
      "col": 0,
      "lesson": [
        {
          "title": "Scalar Subqueries",
          "content": "A subquery that returns one value.\n\n```sql\n-- Students with above-average GPA\nSELECT name FROM students\nWHERE gpa > (\n    SELECT AVG(gpa) FROM students\n);\n```"
        },
        {
          "title": "IN Clause",
          "content": "A subquery that returns a list.\n\n```sql\nSELECT * FROM courses\nWHERE dept_id IN (\n    SELECT dept_id FROM departments\n    WHERE building = 'Engineering Hall'\n);\n```"
        }
      ],
      "questions": [
        {
          "id": "q5_1",
          "type": "freeform-sql",
          "goal": "Scalar Subquery",
          "q": "Find students whose GPA is higher than student ID 1's GPA.",
          "a": [
            "SELECT * FROM students WHERE gpa > (SELECT gpa FROM students WHERE id = 1)"
          ],
          "ctx": [
            "students"
          ],
          "hint": "Put the subquery in parentheses."
        },
        {
          "id": "q5_2",
          "type": "fill-blank",
          "goal": "IN syntax",
          "q": "SELECT * FROM students WHERE id ____ (SELECT student_id FROM enrollments);",
          "a": "IN",
          "ctx": [
            "students"
          ],
          "hint": "We are checking if the ID exists in a list."
        },
        {
          "id": "q5_3",
          "type": "freeform-sql",
          "goal": "Subquery in SELECT",
          "q": "Select the department `name` and the count of courses in it (using a subquery in SELECT).",
          "a": [
            "SELECT name, (SELECT COUNT(*) FROM courses WHERE courses.dept_id = departments.dept_id) FROM departments",
            "SELECT name, (SELECT COUNT(*) FROM courses WHERE dept_id = departments.dept_id) FROM departments"
          ],
          "ctx": [
            "departments",
            "courses"
          ],
          "hint": "This is a correlated subquery in the column list."
        }
      ]
    },
    {
      "id": "r6",
      "name": "Window Functions",
      "description": "Advanced analytics with OVER() and PARTITION BY.",
      "prerequisites": [
        "r4"
      ],
      "row": 3,
      "col": 1,
      "lesson": [
        {
          "title": "The OVER Clause",
          "content": "Window functions see the whole set without collapsing rows (unlike GROUP BY).\n\n```sql\nSELECT name, gpa,\n  RANK() OVER (ORDER BY gpa DESC)\nFROM students;\n```\nThis assigns a rank 1, 2, 3... to each student based on GPA."
        },
        {
          "title": "PARTITION BY",
          "content": "Restart the calculation for each group.\n\n```sql\nSELECT name, major, gpa,\n  RANK() OVER (PARTITION BY major ORDER BY gpa DESC)\nFROM students;\n```\nThe top student *in each major* gets Rank 1."
        }
      ],
      "questions": [
        {
          "id": "q6_1",
          "type": "code-ordering",
          "goal": "Basic Rank",
          "q": "Rank students by GPA highest to lowest.",
          "a": [
            "SELECT",
            "RANK()",
            "OVER",
            "(",
            "ORDER BY",
            "gpa",
            "DESC",
            ")",
            "FROM",
            "students"
          ],
          "ctx": [
            "students"
          ],
          "hint": "RANK() OVER (ORDER BY ...)",
          "distractors": [
            "GROUP BY"
          ]
        },
        {
          "id": "q6_2",
          "type": "freeform-sql",
          "goal": "Partitioned Row Number",
          "q": "Assign a `row_number()` to enrollments, ordered by grade, restarted for each `course_id`.",
          "a": [
            "SELECT row_number() OVER (PARTITION BY course_id ORDER BY grade) FROM enrollments"
          ],
          "ctx": [
            "enrollments"
          ],
          "hint": "Use PARTITION BY to restart the count for each course."
        },
        {
          "id": "q6_3",
          "type": "multiple-choice",
          "goal": "Theory",
          "q": "What is the difference between ROW_NUMBER() and RANK() if two students tie?",
          "choices": [
            "ROW_NUMBER gives unique IDs (1, 2), RANK gives same ID (1, 1)",
            "RANK gives unique IDs, ROW_NUMBER gives same",
            "They are identical"
          ],
          "a": "ROW_NUMBER gives unique IDs (1, 2), RANK gives same ID (1, 1)",
          "ctx": [],
          "hint": "Think of a race where two people cross the line at once.",
          "distractors": []
        }
      ]
    },
    {
      "id": "r7",
      "name": "Advanced Mastery (CTEs)",
      "description": "Clean up complex logic with Common Table Expressions.",
      "prerequisites": [
        "r5",
        "r6"
      ],
      "row": 4,
      "col": 0,
      "lesson": [
        {
          "title": "What is a CTE?",
          "content": "A Common Table Expression (`WITH`) is like a temporary variable for a query.\n\n```sql\nWITH Honors AS (\n  SELECT * FROM students WHERE gpa > 3.8\n)\nSELECT * FROM Honors;\n```\nIt makes complex nested subqueries much more readable."
        }
      ],
      "questions": [
        {
          "id": "q7_1",
          "type": "code-ordering",
          "goal": "CTE Syntax",
          "q": "Structure a CTE called 'TopStudents'.",
          "a": [
            "WITH",
            "TopStudents",
            "AS",
            "(",
            "SELECT * FROM students",
            ")",
            "SELECT * FROM TopStudents"
          ],
          "ctx": [
            "students"
          ],
          "hint": "WITH Name AS (...)",
          "distractors": [
            "CREATE VIEW"
          ]
        },
        {
          "id": "q7_2",
          "type": "freeform-sql",
          "goal": "Write a full CTE query",
          "q": "Define a CTE `Failures` for grades < 60. Then Select count(*) from `Failures`.",
          "a": [
            "WITH Failures AS (SELECT * FROM enrollments WHERE grade < 60) SELECT COUNT(*) FROM Failures"
          ],
          "ctx": [
            "enrollments"
          ],
          "hint": "Start with WITH Failures AS..."
        },
        {
          "id": "q7_3",
          "type": "spot-error",
          "goal": "Identify CTE Scope Error",
          "q": "Why fails? `WITH T1 AS (...) SELECT * FROM students; SELECT * FROM T1;`",
          "a": "CTE only exists for the duration of the very next query.",
          "choices": [
            "CTE only exists for the duration of the very next query.",
            "T1 is a reserved keyword.",
            "You cannot select from students."
          ],
          "ctx": [
            "students"
          ],
          "hint": "CTEs are not permanent tables. They vanish after the semicolon.",
          "distractors": []
        }
      ]
    }
  ]
}